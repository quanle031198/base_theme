(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('flat')) :
    typeof define === 'function' && define.amd ? define('@ngneat/transloco', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', 'flat'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ngneat = global.ngneat || {}, global.ngneat.transloco = {}), global.ng.core, global.rxjs, global.rxjs.operators, global.flat));
}(this, (function (exports, i0, rxjs, operators, flat) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var DefaultLoader = /** @class */ (function () {
        function DefaultLoader(translations) {
            this.translations = translations;
        }
        DefaultLoader.prototype.getTranslation = function (lang) {
            return rxjs.of(this.translations.get(lang) || {});
        };
        return DefaultLoader;
    }());
    var TRANSLOCO_LOADER = new i0.InjectionToken('TRANSLOCO_LOADER');

    function getValue(obj, path) {
        if (!obj) {
            return obj;
        }
        /* For cases where the key is like: 'general.something.thing' */
        if (Object.prototype.hasOwnProperty.call(obj, path)) {
            return obj[path];
        }
        return path.split('.').reduce(function (p, c) { return p === null || p === void 0 ? void 0 : p[c]; }, obj);
    }
    function setValue(obj, prop, val) {
        obj = Object.assign({}, obj);
        var split = prop.split('.');
        var lastIndex = split.length - 1;
        split.reduce(function (acc, part, index) {
            if (index === lastIndex) {
                acc[part] = val;
            }
            else {
                acc[part] = Array.isArray(acc[part])
                    ? acc[part].slice()
                    : Object.assign({}, acc[part]);
            }
            return acc && acc[part];
        }, obj);
        return obj;
    }
    function size(collection) {
        if (!collection) {
            return 0;
        }
        if (Array.isArray(collection)) {
            return collection.length;
        }
        if (isObject(collection)) {
            return Object.keys(collection).length;
        }
        return collection ? collection.length : 0;
    }
    function isEmpty(collection) {
        return size(collection) === 0;
    }
    function isFunction(val) {
        return typeof val === 'function';
    }
    function isString(val) {
        return typeof val === 'string';
    }
    function isNumber(val) {
        return typeof val === 'number';
    }
    function isObject(item) {
        return !!item && typeof item === 'object' && !Array.isArray(item);
    }
    function coerceArray(value) {
        return Array.isArray(value) ? value : [value];
    }
    /*
     * @example
     *
     * given: path-to-happiness => pathToHappiness
     * given: path_to_happiness => pathToHappiness
     * given: path-to_happiness => pathToHappiness
     *
     */
    function toCamelCase(str) {
        return str
            .replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) { return index == 0 ? word.toLowerCase() : word.toUpperCase(); })
            .replace(/\s+|_|-|\//g, '');
    }
    function isBrowser() {
        return typeof window !== 'undefined';
    }
    function isNil(value) {
        return value === null || value === undefined;
    }
    function isDefined(value) {
        return isNil(value) === false;
    }
    function toNumber(value) {
        if (isNumber(value))
            return value;
        if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {
            return Number(value);
        }
        return null;
    }
    function isScopeObject(item) {
        return item && typeof item.scope === 'string';
    }
    function hasInlineLoader(item) {
        return item && isObject(item.loader);
    }
    function unflatten(obj) {
        return flat.unflatten(obj);
    }
    function flatten(obj) {
        return flat.flatten(obj, { safe: true });
    }

    var TRANSLOCO_CONFIG = new i0.InjectionToken('TRANSLOCO_CONFIG', {
        providedIn: 'root',
        factory: function () {
            return { defaultLang: 'en' };
        },
    });
    var defaultConfig = {
        defaultLang: 'en',
        reRenderOnLangChange: false,
        prodMode: false,
        failedRetries: 2,
        availableLangs: [],
        missingHandler: {
            logMissingKey: true,
            useFallbackTranslation: false,
            allowEmpty: false,
        },
        flatten: {
            aot: false,
        },
        interpolation: ['{{', '}}'],
    };
    /**
     * Sets up TranslocoConfig object.
     *
     * @param config The partial config object to load, this is optional,
     * will be spread after defaultConfig.
     */
    function translocoConfig(config) {
        if (config === void 0) { config = defaultConfig; }
        return Object.assign(Object.assign({}, defaultConfig), config);
    }

    var TRANSLOCO_TRANSPILER = new i0.InjectionToken('TRANSLOCO_TRANSPILER');
    var DefaultTranspiler = /** @class */ (function () {
        function DefaultTranspiler(userConfig) {
            this.interpolationMatcher = resolveMatcher(userConfig);
        }
        DefaultTranspiler.prototype.transpile = function (value, params, translation) {
            var _this = this;
            if (params === void 0) { params = {}; }
            if (isString(value)) {
                return value.replace(this.interpolationMatcher, function (_, match) {
                    match = match.trim();
                    if (isDefined(params[match])) {
                        return params[match];
                    }
                    return isDefined(translation[match])
                        ? _this.transpile(translation[match], params, translation)
                        : '';
                });
            }
            else if (params) {
                if (isObject(value)) {
                    value = this.handleObject(value, params, translation);
                }
                else if (Array.isArray(value)) {
                    value = this.handleArray(value, params, translation);
                }
            }
            return value;
        };
        /**
         *
         * @example
         *
         * const en = {
         *  a: {
         *    b: {
         *      c: "Hello {{ value }}"
         *    }
         *  }
         * }
         *
         * const params =  {
         *  "b.c": { value: "Transloco "}
         * }
         *
         * service.selectTranslate('a', params);
         *
         * // the first param will be the result of `en.a`.
         * // the second param will be `params`.
         * parser.transpile(value, params, {});
         *
         *
         */
        DefaultTranspiler.prototype.handleObject = function (value, params, translation) {
            var _this = this;
            if (params === void 0) { params = {}; }
            var result = value;
            Object.keys(params).forEach(function (p) {
                // get the value of "b.c" inside "a" => "Hello {{ value }}"
                var v = getValue(result, p);
                // get the params of "b.c" => { value: "Transloco" }
                var getParams = getValue(params, p);
                // transpile the value => "Hello Transloco"
                var transpiled = _this.transpile(v, getParams, translation);
                // set "b.c" to `transpiled`
                result = setValue(result, p, transpiled);
            });
            return result;
        };
        DefaultTranspiler.prototype.handleArray = function (value, params, translation) {
            var _this = this;
            if (params === void 0) { params = {}; }
            return value.map(function (v) { return _this.transpile(v, params, translation); });
        };
        return DefaultTranspiler;
    }());
    DefaultTranspiler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultTranspiler, deps: [{ token: TRANSLOCO_CONFIG, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DefaultTranspiler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultTranspiler });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultTranspiler, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [TRANSLOCO_CONFIG]
                        }] }];
        } });
    function resolveMatcher(userConfig) {
        var _a = __read(userConfig && userConfig.interpolation
            ? userConfig.interpolation
            : defaultConfig.interpolation, 2), start = _a[0], end = _a[1];
        return new RegExp(start + "(.*?)" + end, 'g');
    }
    function getFunctionArgs(argsString) {
        var splitted = argsString ? argsString.split(',') : [];
        var args = [];
        for (var i = 0; i < splitted.length; i++) {
            var value = splitted[i].trim();
            while (value[value.length - 1] === '\\') {
                i++;
                value = value.replace('\\', ',') + splitted[i];
            }
            args.push(value);
        }
        return args;
    }
    var FunctionalTranspiler = /** @class */ (function (_super) {
        __extends(FunctionalTranspiler, _super);
        function FunctionalTranspiler(injector) {
            var _this = _super.call(this) || this;
            _this.injector = injector;
            return _this;
        }
        FunctionalTranspiler.prototype.transpile = function (value, params, translation) {
            var _this = this;
            if (params === void 0) { params = {}; }
            var transpiled = value;
            if (isString(value)) {
                transpiled = value.replace(/\[\[\s*(\w+)\((.*)\)\s*]]/g, function (match, functionName, args) {
                    try {
                        var func = _this.injector.get(functionName);
                        return func.transpile.apply(func, __spreadArray([], __read(getFunctionArgs(args))));
                    }
                    catch (e) {
                        var message = "There is an error in: '" + value + "'. \n                          Check that the you used the right syntax in your translation and that the implementation of " + functionName + " is correct.";
                        if (e.message.includes('NullInjectorError')) {
                            message = "You are using the '" + functionName + "' function in your translation but no provider was found!";
                        }
                        throw new Error(message);
                    }
                });
            }
            return _super.prototype.transpile.call(this, transpiled, params, translation);
        };
        return FunctionalTranspiler;
    }(DefaultTranspiler));
    FunctionalTranspiler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: FunctionalTranspiler, deps: [{ token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FunctionalTranspiler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: FunctionalTranspiler });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: FunctionalTranspiler, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }]; } });

    var TRANSLOCO_MISSING_HANDLER = new i0.InjectionToken('TRANSLOCO_MISSING_HANDLER');
    var DefaultHandler = /** @class */ (function () {
        function DefaultHandler() {
        }
        DefaultHandler.prototype.handle = function (key, config) {
            if (config.missingHandler.logMissingKey && !config.prodMode) {
                var msg = "Missing translation for '" + key + "'";
                console.warn("%c " + msg, 'font-size: 12px; color: red');
            }
            return key;
        };
        return DefaultHandler;
    }());
    DefaultHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultHandler, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DefaultHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultHandler });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultHandler, decorators: [{
                type: i0.Injectable
            }] });

    var TRANSLOCO_INTERCEPTOR = new i0.InjectionToken('TRANSLOCO_INTERCEPTOR');
    var DefaultInterceptor = /** @class */ (function () {
        function DefaultInterceptor() {
        }
        DefaultInterceptor.prototype.preSaveTranslation = function (translation) {
            return translation;
        };
        DefaultInterceptor.prototype.preSaveTranslationKey = function (_, value) {
            return value;
        };
        return DefaultInterceptor;
    }());
    DefaultInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultInterceptor, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DefaultInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultInterceptor });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultInterceptor, decorators: [{
                type: i0.Injectable
            }] });

    var TRANSLOCO_FALLBACK_STRATEGY = new i0.InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');
    var DefaultFallbackStrategy = /** @class */ (function () {
        function DefaultFallbackStrategy(userConfig) {
            this.userConfig = userConfig;
        }
        DefaultFallbackStrategy.prototype.getNextLangs = function () {
            var fallbackLang = this.userConfig.fallbackLang;
            if (!fallbackLang) {
                throw new Error('When using the default fallback, a fallback language must be provided in the config!');
            }
            return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];
        };
        return DefaultFallbackStrategy;
    }());
    DefaultFallbackStrategy.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultFallbackStrategy, deps: [{ token: TRANSLOCO_CONFIG }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DefaultFallbackStrategy.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultFallbackStrategy });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DefaultFallbackStrategy, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [TRANSLOCO_CONFIG]
                        }] }];
        } });

    function mergeConfig(defaultConfig, userConfig) {
        return Object.assign(Object.assign(Object.assign({}, defaultConfig), userConfig), { missingHandler: Object.assign(Object.assign({}, defaultConfig.missingHandler), userConfig.missingHandler), flatten: Object.assign(Object.assign({}, defaultConfig.flatten), userConfig.flatten) });
    }

    /*
     * @example
     *
     * given: lazy-page/en => lazy-page
     *
     */
    function getScopeFromLang(lang) {
        if (!lang) {
            return '';
        }
        var split = lang.split('/');
        split.pop();
        return split.join('/');
    }
    /*
     * @example
     *
     * given: lazy-page/en => en
     *
     */
    function getLangFromScope(lang) {
        if (!lang) {
            return '';
        }
        return lang.split('/').pop();
    }
    /**
     * @example
     *
     * getPipeValue('todos|scoped', 'scoped') [true, 'todos']
     * getPipeValue('en|static', 'static') [true, 'en']
     * getPipeValue('en', 'static') [false, 'en']
     */
    function getPipeValue(str, value, char) {
        if (char === void 0) { char = '|'; }
        if (isString(str)) {
            var splitted = str.split(char);
            var lastItem = splitted.pop();
            return lastItem === value ? [true, splitted.toString()] : [false, lastItem];
        }
        return [false, ''];
    }
    function shouldListenToLangChanges(service, lang) {
        var _a = __read(getPipeValue(lang, 'static'), 1), hasStatic = _a[0];
        if (!hasStatic) {
            // If we didn't get 'lang|static' check if it's set in the global level
            return !!service.config.reRenderOnLangChange;
        }
        // We have 'lang|static' so don't listen to lang changes
        return false;
    }
    function listenOrNotOperator(listenToLangChange) {
        return listenToLangChange ? function (source) { return source; } : operators.take(1);
    }
    function prependScope(inlineLoader, scope) {
        return Object.keys(inlineLoader).reduce(function (acc, lang) {
            acc[scope + "/" + lang] = inlineLoader[lang];
            return acc;
        }, {});
    }
    function resolveInlineLoader(providerScope, scope) {
        return hasInlineLoader(providerScope)
            ? prependScope(providerScope.loader, scope)
            : undefined;
    }
    function getEventPayload(lang) {
        return {
            scope: getScopeFromLang(lang) || null,
            langName: getLangFromScope(lang),
        };
    }

    function resolveLoader(options) {
        var path = options.path, inlineLoader = options.inlineLoader, mainLoader = options.mainLoader, data = options.data;
        if (inlineLoader) {
            var pathLoader = inlineLoader[path];
            if (isFunction(pathLoader) === false) {
                throw "You're using an inline loader but didn't provide a loader for " + path;
            }
            return inlineLoader[path]().then(function (res) { return res.default ? res.default : res; });
        }
        return mainLoader.getTranslation(path, data);
    }

    function getFallbacksLoaders(_a) {
        var mainLoader = _a.mainLoader, path = _a.path, data = _a.data, fallbackPath = _a.fallbackPath, inlineLoader = _a.inlineLoader;
        var paths = fallbackPath ? [path, fallbackPath] : [path];
        return paths.map(function (path) {
            var loader = resolveLoader({ path: path, mainLoader: mainLoader, inlineLoader: inlineLoader, data: data });
            return rxjs.from(loader).pipe(operators.map(function (translation) { return ({
                translation: translation,
                lang: path,
            }); }));
        });
    }

    var service;
    function translate(key, params, lang) {
        if (params === void 0) { params = {}; }
        return service.translate(key, params, lang);
    }
    var TranslocoService = /** @class */ (function () {
        function TranslocoService(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {
            var _this = this;
            this.loader = loader;
            this.parser = parser;
            this.missingHandler = missingHandler;
            this.interceptor = interceptor;
            this.userConfig = userConfig;
            this.fallbackStrategy = fallbackStrategy;
            this.subscription = null;
            this.translations = new Map();
            this.cache = new Map();
            this.defaultLang = '';
            this.availableLangs = [];
            this.isResolvedMissingOnce = false;
            this.failedLangs = new Set();
            this.events = new rxjs.Subject();
            this.events$ = this.events.asObservable();
            if (!this.loader) {
                this.loader = new DefaultLoader(this.translations);
            }
            service = this;
            this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);
            this.setAvailableLangs(this.mergedConfig.availableLangs || []);
            this.setFallbackLangForMissingTranslation(this.mergedConfig);
            this.setDefaultLang(this.mergedConfig.defaultLang);
            this.lang = new rxjs.BehaviorSubject(this.getDefaultLang());
            // Don't use distinctUntilChanged as we need the ability to update
            // the value when using setTranslation or setTranslationKeys
            this.langChanges$ = this.lang.asObservable();
            /**
             * When we have a failure, we want to define the next language that succeeded as the active
             */
            this.subscription = this.events$.subscribe(function (e) {
                if (e.type === 'translationLoadSuccess' && e.wasFailure) {
                    _this.setActiveLang(e.payload.langName);
                }
            });
        }
        Object.defineProperty(TranslocoService.prototype, "config", {
            get: function () {
                return this.mergedConfig;
            },
            enumerable: false,
            configurable: true
        });
        TranslocoService.prototype.getDefaultLang = function () {
            return this.defaultLang;
        };
        TranslocoService.prototype.setDefaultLang = function (lang) {
            this.defaultLang = lang;
        };
        TranslocoService.prototype.getActiveLang = function () {
            return this.lang.getValue();
        };
        TranslocoService.prototype.setActiveLang = function (lang) {
            var _a, _b;
            this.lang.next(lang);
            (_b = (_a = this.parser).onLangChanged) === null || _b === void 0 ? void 0 : _b.call(_a, lang);
            return this;
        };
        TranslocoService.prototype.setAvailableLangs = function (langs) {
            this.availableLangs = langs;
        };
        /**
         * Gets the available languages.
         *
         * @returns
         * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
         * depending on how the available languages are set in your module.
         */
        TranslocoService.prototype.getAvailableLangs = function () {
            return this.availableLangs;
        };
        TranslocoService.prototype.load = function (path, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var cached = this.cache.get(path);
            if (cached) {
                return cached;
            }
            var loadTranslation;
            var isScope = this._isLangScoped(path);
            var scope;
            if (isScope) {
                scope = getScopeFromLang(path);
            }
            var loadersOptions = {
                path: path,
                mainLoader: this.loader,
                inlineLoader: options.inlineLoader,
                data: isScope ? { scope: scope } : undefined,
            };
            if (this.useFallbackTranslation(path)) {
                // if the path is scope the fallback should be `scope/fallbackLang`;
                var fallback = isScope
                    ? scope + "/" + this.firstFallbackLang
                    : this.firstFallbackLang;
                var loaders = getFallbacksLoaders(Object.assign(Object.assign({}, loadersOptions), { fallbackPath: fallback }));
                loadTranslation = rxjs.forkJoin(loaders);
            }
            else {
                var loader = resolveLoader(loadersOptions);
                loadTranslation = rxjs.from(loader);
            }
            var load$ = loadTranslation.pipe(operators.retry(this.config.failedRetries), operators.tap(function (translation) {
                if (Array.isArray(translation)) {
                    translation.forEach(function (t) {
                        _this.handleSuccess(t.lang, t.translation);
                        // Save the fallback in cache so we'll not create a redundant request
                        if (t.lang !== path) {
                            _this.cache.set(t.lang, rxjs.of({}));
                        }
                    });
                    return;
                }
                _this.handleSuccess(path, translation);
            }), operators.catchError(function (error) {
                if (!_this.mergedConfig.prodMode) {
                    console.error("Error while trying to load \"" + path + "\"", error);
                }
                return _this.handleFailure(path, options);
            }), operators.shareReplay(1));
            this.cache.set(path, load$);
            return load$;
        };
        /**
         * Gets the instant translated value of a key
         *
         * @example
         *
         * translate<string>('hello')
         * translate('hello', { value: 'value' })
         * translate<string[]>(['hello', 'key'])
         * translate('hello', { }, 'en')
         * translate('scope.someKey', { }, 'en')
         */
        TranslocoService.prototype.translate = function (key, params, lang) {
            var _this = this;
            if (params === void 0) { params = {}; }
            if (lang === void 0) { lang = this.getActiveLang(); }
            if (!key)
                return key;
            var _c = this.resolveLangAndScope(lang), scope = _c.scope, resolveLang = _c.resolveLang;
            if (Array.isArray(key)) {
                return key.map(function (k) { return _this.translate(scope ? scope + "." + k : k, params, resolveLang); });
            }
            key = scope ? scope + "." + key : key;
            var translation = this.getTranslation(resolveLang);
            var value = translation[key];
            if (!value) {
                return this._handleMissingKey(key, value, params);
            }
            return this.parser.transpile(value, params, translation);
        };
        /**
         * Gets the translated value of a key as observable
         *
         * @example
         *
         * selectTranslate<string>('hello').subscribe(value => ...)
         * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
         * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
         * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
         *
         */
        TranslocoService.prototype.selectTranslate = function (key, params, lang, _isObject) {
            var _this = this;
            if (_isObject === void 0) { _isObject = false; }
            var inlineLoader;
            var load = function (lang, options) { return _this.load(lang, options).pipe(operators.map(function () { return _isObject
                ? _this.translateObject(key, params, lang)
                : _this.translate(key, params, lang); })); };
            if (isNil(lang)) {
                return this.langChanges$.pipe(operators.switchMap(function (lang) { return load(lang); }));
            }
            if (isScopeObject(lang)) {
                // it's a scope object.
                var providerScope = lang;
                lang = providerScope.scope;
                inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);
            }
            lang = lang;
            if (this.isLang(lang) || this.isScopeWithLang(lang)) {
                return load(lang);
            }
            // it's a scope
            var scope = lang;
            return this.langChanges$.pipe(operators.switchMap(function (lang) { return load(scope + "/" + lang, { inlineLoader: inlineLoader }); }));
        };
        /**
         * Whether the scope with lang
         *
         * @example
         *
         * todos/en => true
         * todos => false
         */
        TranslocoService.prototype.isScopeWithLang = function (lang) {
            return this.isLang(getLangFromScope(lang));
        };
        TranslocoService.prototype.translateObject = function (key, params, lang) {
            var e_1, _c;
            var _this = this;
            if (params === void 0) { params = {}; }
            if (lang === void 0) { lang = this.getActiveLang(); }
            if (isString(key) || Array.isArray(key)) {
                if (Array.isArray(key)) {
                    return key.map(function (k) { return _this.translateObject(scope_1 ? scope_1 + "." + k : k, params, resolveLang_1); });
                }
                var _d = this.resolveLangAndScope(lang), resolveLang_1 = _d.resolveLang, scope_1 = _d.scope;
                var translation = this.getTranslation(resolveLang_1);
                key = scope_1 ? scope_1 + "." + key : key;
                var value = unflatten(this.getObjectByKey(translation, key));
                /* If an empty object was returned we want to try and translate the key as a string and not an object */
                return isEmpty(value)
                    ? this.translate(key, params, lang)
                    : this.parser.transpile(value, params, translation);
            }
            var translations = [];
            try {
                for (var _e = __values(this.getEntries(key)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var _g = __read(_f.value, 2), _key = _g[0], _params = _g[1];
                    translations.push(this.translateObject(_key, _params, lang));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return translations;
        };
        TranslocoService.prototype.selectTranslateObject = function (key, params, lang) {
            var _this = this;
            if (isString(key) || Array.isArray(key)) {
                return this.selectTranslate(key, params, lang, true);
            }
            var _c = __read(this.getEntries(key)), _d = __read(_c[0], 2), firstKey = _d[0], firstParams = _d[1], rest = _c.slice(1);
            /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,
             * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */
            return this.selectTranslateObject(firstKey, firstParams, lang).pipe(operators.map(function (value) {
                var e_2, _c;
                var translations = [value];
                try {
                    for (var rest_1 = __values(rest), rest_1_1 = rest_1.next(); !rest_1_1.done; rest_1_1 = rest_1.next()) {
                        var _d = __read(rest_1_1.value, 2), _key = _d[0], _params = _d[1];
                        translations.push(_this.translateObject(_key, _params, lang));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (rest_1_1 && !rest_1_1.done && (_c = rest_1.return)) _c.call(rest_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return translations;
            }));
        };
        TranslocoService.prototype.getTranslation = function (langOrScope) {
            if (langOrScope) {
                if (this.isLang(langOrScope)) {
                    return this.translations.get(langOrScope) || {};
                }
                else {
                    // This is a scope, build the scope value from the translation object
                    var _c = this.resolveLangAndScope(langOrScope), scope = _c.scope, resolveLang = _c.resolveLang;
                    var translation = this.translations.get(resolveLang) || {};
                    return this.getObjectByKey(translation, scope);
                }
            }
            return this.translations;
        };
        /**
         * Gets an object of translations for a given language
         *
         * @example
         *
         * selectTranslation().subscribe() - will return the current lang translation
         * selectTranslation('es').subscribe()
         * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
         * selectTranslation('admin-page/es').subscribe()
         */
        TranslocoService.prototype.selectTranslation = function (lang) {
            var _this = this;
            var language$ = this.langChanges$;
            if (lang) {
                var scopeLangSpecified = getLangFromScope(lang) !== lang;
                if (this.isLang(lang) || scopeLangSpecified) {
                    language$ = rxjs.of(lang);
                }
                else {
                    language$ = this.langChanges$.pipe(operators.map(function (currentLang) { return lang + "/" + currentLang; }));
                }
            }
            return language$.pipe(operators.switchMap(function (language) { return _this.load(language).pipe(operators.map(function () { return _this.getTranslation(language); })); }));
        };
        /**
         * Sets or merge a given translation object to current lang
         *
         * @example
         *
         * setTranslation({ ... })
         * setTranslation({ ... }, 'en')
         * setTranslation({ ... }, 'es', { merge: false } )
         * setTranslation({ ... }, 'todos/en', { merge: false } )
         */
        TranslocoService.prototype.setTranslation = function (translation, lang, options) {
            var _c;
            if (lang === void 0) { lang = this.getActiveLang(); }
            if (options === void 0) { options = {}; }
            var defaults = { merge: true, emitChange: true };
            var mergedOptions = Object.assign(Object.assign({}, defaults), options);
            var scope = getScopeFromLang(lang);
            /**
             * If this isn't a scope we use the whole translation as is
             * otherwise we need to flat the scope and use it
             */
            var flattenScopeOrTranslation = translation;
            // Merged the scoped language into the active language
            if (scope) {
                var key = this.getMappedScope(scope);
                flattenScopeOrTranslation = flatten((_c = {}, _c[key] = translation, _c));
            }
            var currentLang = scope ? getLangFromScope(lang) : lang;
            var mergedTranslation = Object.assign(Object.assign({}, (mergedOptions.merge && this.getTranslation(currentLang))), flattenScopeOrTranslation);
            var flattenTranslation = this.mergedConfig.flatten.aot
                ? mergedTranslation
                : flatten(mergedTranslation);
            var withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);
            this.translations.set(currentLang, withHook);
            mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());
        };
        /**
         * Sets translation key with given value
         *
         * @example
         *
         * setTranslationKey('key', 'value')
         * setTranslationKey('key.nested', 'value')
         * setTranslationKey('key.nested', 'value', 'en')
         * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )
         */
        TranslocoService.prototype.setTranslationKey = function (key, value, 
        // Todo: Add the lang to the options in v3
        lang, options) {
            var _c;
            if (lang === void 0) { lang = this.getActiveLang(); }
            if (options === void 0) { options = {}; }
            var withHook = this.interceptor.preSaveTranslationKey(key, value, lang);
            var newValue = (_c = {},
                _c[key] = withHook,
                _c);
            this.setTranslation(newValue, lang, Object.assign(Object.assign({}, options), { merge: true }));
        };
        /**
         * Sets the fallback lang for the currently active language
         * @param fallbackLang
         */
        TranslocoService.prototype.setFallbackLangForMissingTranslation = function (_c) {
            var fallbackLang = _c.fallbackLang;
            var lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;
            if (fallbackLang && this.useFallbackTranslation(lang)) {
                this.firstFallbackLang = lang;
            }
        };
        /**
         * @internal
         */
        TranslocoService.prototype._handleMissingKey = function (key, value, params) {
            if (this.config.missingHandler.allowEmpty && value === '') {
                return '';
            }
            if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {
                // We need to set it to true to prevent a loop
                this.isResolvedMissingOnce = true;
                var fallbackValue = this.translate(key, params, this.firstFallbackLang);
                this.isResolvedMissingOnce = false;
                return fallbackValue;
            }
            return this.missingHandler.handle(key, this.getMissingHandlerData(), params);
        };
        /**
         * @internal
         */
        TranslocoService.prototype._isLangScoped = function (lang) {
            return this.getAvailableLangsIds().indexOf(lang) === -1;
        };
        /**
         * Checks if a given string is one of the specified available languages.
         * @returns
         * True if the given string is an available language.
         * False if the given string is not an available language.
         */
        TranslocoService.prototype.isLang = function (lang) {
            return this.getAvailableLangsIds().indexOf(lang) !== -1;
        };
        /**
         * @internal
         *
         * We always want to make sure the global lang is loaded
         * before loading the scope since you can access both via the pipe/directive.
         */
        TranslocoService.prototype._loadDependencies = function (path, inlineLoader) {
            var mainLang = getLangFromScope(path);
            if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {
                return rxjs.combineLatest(this.load(mainLang), this.load(path, { inlineLoader: inlineLoader }));
            }
            return this.load(path, { inlineLoader: inlineLoader });
        };
        /**
         * @internal
         */
        TranslocoService.prototype._completeScopeWithLang = function (langOrScope) {
            if (this._isLangScoped(langOrScope) &&
                !this.isLang(getLangFromScope(langOrScope))) {
                return langOrScope + "/" + this.getActiveLang();
            }
            return langOrScope;
        };
        /**
         * @internal
         */
        TranslocoService.prototype._setScopeAlias = function (scope, alias) {
            if (!this.mergedConfig.scopeMapping) {
                this.mergedConfig.scopeMapping = {};
            }
            this.mergedConfig.scopeMapping[scope] = alias;
        };
        TranslocoService.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
                // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
                // callback within its `destination` property, preventing classes from being GC'd.
                this.subscription = null;
            }
            // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.
            // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from
            // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created
            // and destroyed per each HTTP request, but any service is not getting GC'd.
            this.cache.clear();
        };
        TranslocoService.prototype.isLoadedTranslation = function (lang) {
            return size(this.getTranslation(lang));
        };
        TranslocoService.prototype.getAvailableLangsIds = function () {
            var first = this.getAvailableLangs()[0];
            if (isString(first)) {
                return this.getAvailableLangs();
            }
            return this.getAvailableLangs().map(function (l) { return l.id; });
        };
        TranslocoService.prototype.getMissingHandlerData = function () {
            return Object.assign(Object.assign({}, this.config), { activeLang: this.getActiveLang(), availableLangs: this.availableLangs, defaultLang: this.defaultLang });
        };
        /**
         * Use a fallback translation set for missing keys of the primary language
         * This is unrelated to the fallback language (which changes the active language)
         */
        TranslocoService.prototype.useFallbackTranslation = function (lang) {
            return (this.config.missingHandler.useFallbackTranslation &&
                lang !== this.firstFallbackLang);
        };
        TranslocoService.prototype.handleSuccess = function (lang, translation) {
            var _this = this;
            this.setTranslation(translation, lang, { emitChange: false });
            this.events.next({
                wasFailure: !!this.failedLangs.size,
                type: 'translationLoadSuccess',
                payload: getEventPayload(lang),
            });
            this.failedLangs.forEach(function (l) { return _this.cache.delete(l); });
            this.failedLangs.clear();
        };
        TranslocoService.prototype.handleFailure = function (lang, loadOptions) {
            // When starting to load a first choice language, initialize
            // the failed counter and resolve the fallback langs.
            if (isNil(loadOptions.failedCounter)) {
                loadOptions.failedCounter = 0;
                if (!loadOptions.fallbackLangs) {
                    loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);
                }
            }
            var splitted = lang.split('/');
            var fallbacks = loadOptions.fallbackLangs;
            var nextLang = fallbacks[loadOptions.failedCounter];
            this.failedLangs.add(lang);
            // This handles the case where a loaded fallback language is requested again
            if (this.cache.has(nextLang)) {
                this.handleSuccess(nextLang, this.getTranslation(nextLang));
                return rxjs.EMPTY;
            }
            var isFallbackLang = nextLang === splitted[splitted.length - 1];
            if (!nextLang || isFallbackLang) {
                var msg = "Unable to load translation and all the fallback languages";
                if (splitted.length > 1) {
                    msg += ", did you misspelled the scope name?";
                }
                throw new Error(msg);
            }
            var resolveLang = nextLang;
            // if it's scoped lang
            if (splitted.length > 1) {
                // We need to resolve it to:
                // todos/langNotExists => todos/nextLang
                splitted[splitted.length - 1] = nextLang;
                resolveLang = splitted.join('/');
            }
            loadOptions.failedCounter++;
            this.events.next({
                type: 'translationLoadFailure',
                payload: getEventPayload(lang),
            });
            return this.load(resolveLang, loadOptions);
        };
        TranslocoService.prototype.getMappedScope = function (scope) {
            var _c = this.config.scopeMapping, scopeMapping = _c === void 0 ? {} : _c;
            return scopeMapping[scope] || toCamelCase(scope);
        };
        /**
         * If lang is scope we need to check the following cases:
         * todos/es => in this case we should take `es` as lang
         * todos => in this case we should set the active lang as lang
         */
        TranslocoService.prototype.resolveLangAndScope = function (lang) {
            var resolveLang = lang;
            var scope;
            if (this._isLangScoped(lang)) {
                // en for example
                var langFromScope = getLangFromScope(lang);
                // en is lang
                var hasLang = this.isLang(langFromScope);
                // take en
                resolveLang = hasLang ? langFromScope : this.getActiveLang();
                // find the scope
                scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);
            }
            return { scope: scope, resolveLang: resolveLang };
        };
        TranslocoService.prototype.getObjectByKey = function (translation, key) {
            var result = {};
            var prefix = key + ".";
            for (var currentKey in translation) {
                if (currentKey.startsWith(prefix)) {
                    result[currentKey.replace(prefix, '')] = translation[currentKey];
                }
            }
            return result;
        };
        TranslocoService.prototype.getEntries = function (key) {
            return key instanceof Map ? key.entries() : Object.entries(key);
        };
        return TranslocoService;
    }());
    TranslocoService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoService, deps: [{ token: TRANSLOCO_LOADER, optional: true }, { token: TRANSLOCO_TRANSPILER }, { token: TRANSLOCO_MISSING_HANDLER }, { token: TRANSLOCO_INTERCEPTOR }, { token: TRANSLOCO_CONFIG }, { token: TRANSLOCO_FALLBACK_STRATEGY }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TranslocoService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [TRANSLOCO_LOADER]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [TRANSLOCO_TRANSPILER]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [TRANSLOCO_MISSING_HANDLER]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [TRANSLOCO_INTERCEPTOR]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [TRANSLOCO_CONFIG]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [TRANSLOCO_FALLBACK_STRATEGY]
                        }] }];
        } });

    var TranslocoLoaderComponent = /** @class */ (function () {
        function TranslocoLoaderComponent() {
        }
        return TranslocoLoaderComponent;
    }());
    TranslocoLoaderComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoLoaderComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    TranslocoLoaderComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: TranslocoLoaderComponent, selector: "ng-component", inputs: { html: "html" }, ngImport: i0__namespace, template: "\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  ", isInline: true });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoLoaderComponent, decorators: [{
                type: i0.Component,
                args: [{
                        template: "\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  ",
                    }]
            }], propDecorators: { html: [{
                    type: i0.Input
                }] } });

    var TemplateHandler = /** @class */ (function () {
        function TemplateHandler(view, vcr) {
            this.view = view;
            this.vcr = vcr;
            this.injector = this.vcr.injector;
        }
        TemplateHandler.prototype.attachView = function () {
            if (this.view instanceof i0.TemplateRef) {
                this.vcr.createEmbeddedView(this.view);
            }
            else if (isString(this.view)) {
                var componentRef = this.createComponent(TranslocoLoaderComponent);
                componentRef.instance.html = this.view;
                componentRef.hostView.detectChanges();
            }
            else {
                this.createComponent(this.view);
            }
        };
        TemplateHandler.prototype.detachView = function () {
            this.vcr.clear();
        };
        TemplateHandler.prototype.createComponent = function (cmp) {
            var cfr = this.injector.get(i0.ComponentFactoryResolver);
            var factory = cfr.resolveComponentFactory(cmp);
            return this.vcr.createComponent(factory);
        };
        return TemplateHandler;
    }());

    var TRANSLOCO_LANG = new i0.InjectionToken('TRANSLOCO_LANG');

    var TRANSLOCO_LOADING_TEMPLATE = new i0.InjectionToken('TRANSLOCO_LOADING_TEMPLATE');

    var TRANSLOCO_SCOPE = new i0.InjectionToken('TRANSLOCO_SCOPE');

    var LangResolver = /** @class */ (function () {
        function LangResolver() {
            this.initialized = false;
        }
        // inline => provider => active
        LangResolver.prototype.resolve = function (_a) {
            var inline = _a.inline, provider = _a.provider, active = _a.active;
            var lang = active;
            /**
             * When the user changes the lang we need to update
             * the view. Otherwise, the lang will remain the inline/provided lang
             */
            if (this.initialized) {
                lang = active;
                return lang;
            }
            if (provider) {
                var _b = __read(getPipeValue(provider, 'static'), 2), extracted = _b[1];
                lang = extracted;
            }
            if (inline) {
                var _c = __read(getPipeValue(inline, 'static'), 2), extracted = _c[1];
                lang = extracted;
            }
            this.initialized = true;
            return lang;
        };
        /**
         *
         * Resolve the lang
         *
         * @example
         *
         * resolveLangBasedOnScope('todos/en') => en
         * resolveLangBasedOnScope('en') => en
         *
         */
        LangResolver.prototype.resolveLangBasedOnScope = function (lang) {
            var scope = getScopeFromLang(lang);
            return scope ? getLangFromScope(lang) : lang;
        };
        /**
         *
         * Resolve the lang path for loading
         *
         * @example
         *
         * resolveLangPath('todos', 'en') => todos/en
         * resolveLangPath('en') => en
         *
         */
        LangResolver.prototype.resolveLangPath = function (lang, scope) {
            return scope ? scope + "/" + lang : lang;
        };
        return LangResolver;
    }());

    var ScopeResolver = /** @class */ (function () {
        function ScopeResolver(translocoService) {
            this.translocoService = translocoService;
        }
        // inline => provider
        ScopeResolver.prototype.resolve = function (_a) {
            var _b = _a === void 0 ? {
                inline: undefined,
                provider: undefined,
            } : _a, inline = _b.inline, provider = _b.provider;
            if (inline) {
                return inline;
            }
            if (provider) {
                if (isScopeObject(provider)) {
                    var scope = provider.scope, _c = provider.alias, alias = _c === void 0 ? toCamelCase(scope) : _c;
                    this.translocoService._setScopeAlias(scope, alias);
                    return scope;
                }
                return provider;
            }
            return undefined;
        };
        return ScopeResolver;
    }());

    var TranslocoDirective = /** @class */ (function () {
        function TranslocoDirective(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {
            this.translocoService = translocoService;
            this.tpl = tpl;
            this.providerScope = providerScope;
            this.providerLang = providerLang;
            this.providedLoadingTpl = providedLoadingTpl;
            this.vcr = vcr;
            this.cdr = cdr;
            this.host = host;
            this.renderer = renderer;
            this.subscription = null;
            this.translationMemo = {};
            this.params = {};
            // Whether we already rendered the view once
            this.initialized = false;
            this.langResolver = new LangResolver();
            this.scopeResolver = new ScopeResolver(this.translocoService);
            this.strategy = this.tpl === null ? 'attribute' : 'structural';
        }
        TranslocoDirective.ngTemplateContextGuard = function (dir, ctx) {
            return true;
        };
        TranslocoDirective.prototype.ngOnInit = function () {
            var _this = this;
            var listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);
            this.subscription = this.translocoService.langChanges$
                .pipe(operators.switchMap(function (activeLang) {
                var lang = _this.langResolver.resolve({
                    inline: _this.inlineLang,
                    provider: _this.providerLang,
                    active: activeLang,
                });
                return Array.isArray(_this.providerScope)
                    ? rxjs.forkJoin(_this.providerScope.map(function (providerScope) { return _this.resolveScope(lang, providerScope); }))
                    : _this.resolveScope(lang, _this.providerScope);
            }), listenOrNotOperator(listenToLangChange))
                .subscribe(function () {
                _this.currentLang = _this.langResolver.resolveLangBasedOnScope(_this.path);
                _this.strategy === 'attribute'
                    ? _this.attributeStrategy()
                    : _this.structuralStrategy(_this.currentLang, _this.inlineRead);
                _this.cdr.markForCheck();
                _this.initialized = true;
            });
            var loadingTpl = this.getLoadingTpl();
            if (!this.initialized && loadingTpl) {
                this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);
                this.loaderTplHandler.attachView();
            }
        };
        TranslocoDirective.prototype.ngOnChanges = function (changes) {
            // We need to support dynamic keys/params, so if this is not the first change CD cycle
            // we need to run the function again in order to update the value
            if (this.strategy === 'attribute') {
                var notInit = Object.keys(changes).some(function (v) { return !changes[v].firstChange; });
                notInit && this.attributeStrategy();
            }
        };
        TranslocoDirective.prototype.attributeStrategy = function () {
            this.detachLoader();
            this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));
        };
        TranslocoDirective.prototype.structuralStrategy = function (lang, read) {
            this.translationMemo = {};
            if (this.view) {
                // when the lang changes we need to change the reference so Angular will update the view
                this.view.context['$implicit'] = this.getTranslateFn(lang, read);
                this.view.context['currentLang'] = this.currentLang;
            }
            else {
                this.detachLoader();
                this.view = this.vcr.createEmbeddedView(this.tpl, {
                    $implicit: this.getTranslateFn(lang, read),
                    currentLang: this.currentLang,
                });
            }
        };
        TranslocoDirective.prototype.getTranslateFn = function (lang, read) {
            var _this = this;
            return function (key, params) {
                var withRead = read ? read + "." + key : key;
                var withParams = params
                    ? "" + withRead + JSON.stringify(params)
                    : withRead;
                if (Object.prototype.hasOwnProperty.call(_this.translationMemo, withParams)) {
                    return _this.translationMemo[withParams].value;
                }
                _this.translationMemo[withParams] = {
                    params: params,
                    value: _this.translocoService.translate(withRead, params, lang),
                };
                return _this.translationMemo[withParams].value;
            };
        };
        TranslocoDirective.prototype.getLoadingTpl = function () {
            return this.inlineTpl || this.providedLoadingTpl;
        };
        TranslocoDirective.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
                // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
                // callback within its `destination` property, preventing classes from being GC'd.
                this.subscription = null;
            }
        };
        TranslocoDirective.prototype.detachLoader = function () {
            var _a;
            (_a = this.loaderTplHandler) === null || _a === void 0 ? void 0 : _a.detachView();
        };
        TranslocoDirective.prototype.resolveScope = function (lang, providerScope) {
            var resolvedScope = this.scopeResolver.resolve({
                inline: this.inlineScope,
                provider: providerScope,
            });
            this.path = this.langResolver.resolveLangPath(lang, resolvedScope);
            var inlineLoader = resolveInlineLoader(providerScope, resolvedScope);
            return this.translocoService._loadDependencies(this.path, inlineLoader);
        };
        return TranslocoDirective;
    }());
    TranslocoDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoDirective, deps: [{ token: TranslocoService }, { token: i0__namespace.TemplateRef, optional: true }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: TRANSLOCO_LOADING_TEMPLATE, optional: true }, { token: i0__namespace.ViewContainerRef }, { token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    TranslocoDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.5", type: TranslocoDirective, selector: "[transloco]", inputs: { key: ["transloco", "key"], params: ["translocoParams", "params"], inlineScope: ["translocoScope", "inlineScope"], inlineRead: ["translocoRead", "inlineRead"], inlineLang: ["translocoLang", "inlineLang"], inlineTpl: ["translocoLoadingTpl", "inlineTpl"] }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[transloco]',
                    }]
            }], ctorParameters: function () {
            return [{ type: TranslocoService }, { type: i0__namespace.TemplateRef, decorators: [{
                            type: i0.Optional
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [TRANSLOCO_SCOPE]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [TRANSLOCO_LANG]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [TRANSLOCO_LOADING_TEMPLATE]
                        }] }, { type: i0__namespace.ViewContainerRef }, { type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }];
        }, propDecorators: { key: [{
                    type: i0.Input,
                    args: ['transloco']
                }], params: [{
                    type: i0.Input,
                    args: ['translocoParams']
                }], inlineScope: [{
                    type: i0.Input,
                    args: ['translocoScope']
                }], inlineRead: [{
                    type: i0.Input,
                    args: ['translocoRead']
                }], inlineLang: [{
                    type: i0.Input,
                    args: ['translocoLang']
                }], inlineTpl: [{
                    type: i0.Input,
                    args: ['translocoLoadingTpl']
                }] } });

    var TranslocoPipe = /** @class */ (function () {
        function TranslocoPipe(translocoService, providerScope, providerLang, cdr) {
            this.translocoService = translocoService;
            this.providerScope = providerScope;
            this.providerLang = providerLang;
            this.cdr = cdr;
            this.subscription = null;
            this.lastValue = '';
            this.langResolver = new LangResolver();
            this.scopeResolver = new ScopeResolver(this.translocoService);
        }
        // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311
        // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488
        TranslocoPipe.prototype.transform = function (key, params, inlineLang) {
            var _this = this;
            var _a;
            if (!key) {
                return key;
            }
            var keyName = params ? "" + key + JSON.stringify(params) : key;
            if (keyName === this.lastKey) {
                return this.lastValue;
            }
            this.lastKey = keyName;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            var listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);
            this.subscription = this.translocoService.langChanges$
                .pipe(operators.switchMap(function (activeLang) {
                var lang = _this.langResolver.resolve({
                    inline: inlineLang,
                    provider: _this.providerLang,
                    active: activeLang,
                });
                return Array.isArray(_this.providerScope)
                    ? rxjs.forkJoin(_this.providerScope.map(function (providerScope) { return _this.resolveScope(lang, providerScope); }))
                    : _this.resolveScope(lang, _this.providerScope);
            }), listenOrNotOperator(listenToLangChange))
                .subscribe(function () { return _this.updateValue(key, params); });
            return this.lastValue;
        };
        TranslocoPipe.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
                // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
                // callback within its `destination` property, preventing classes from being GC'd.
                this.subscription = null;
            }
        };
        TranslocoPipe.prototype.updateValue = function (key, params) {
            var lang = this.langResolver.resolveLangBasedOnScope(this.path);
            this.lastValue = this.translocoService.translate(key, params, lang);
            this.cdr.markForCheck();
        };
        TranslocoPipe.prototype.resolveScope = function (lang, providerScope) {
            var resolvedScope = this.scopeResolver.resolve({
                inline: undefined,
                provider: providerScope,
            });
            this.path = this.langResolver.resolveLangPath(lang, resolvedScope);
            var inlineLoader = resolveInlineLoader(providerScope, resolvedScope);
            return this.translocoService._loadDependencies(this.path, inlineLoader);
        };
        return TranslocoPipe;
    }());
    TranslocoPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoPipe, deps: [{ token: TranslocoService }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    TranslocoPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoPipe, name: "transloco", pure: false });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoPipe, decorators: [{
                type: i0.Pipe,
                args: [{
                        name: 'transloco',
                        pure: false,
                    }]
            }], ctorParameters: function () {
            return [{ type: TranslocoService }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [TRANSLOCO_SCOPE]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [TRANSLOCO_LANG]
                        }] }, { type: i0__namespace.ChangeDetectorRef }];
        } });

    var defaultProviders = [
        {
            provide: TRANSLOCO_TRANSPILER,
            useClass: DefaultTranspiler,
            deps: [TRANSLOCO_CONFIG],
        },
        {
            provide: TRANSLOCO_MISSING_HANDLER,
            useClass: DefaultHandler,
        },
        {
            provide: TRANSLOCO_INTERCEPTOR,
            useClass: DefaultInterceptor,
        },
        {
            provide: TRANSLOCO_FALLBACK_STRATEGY,
            useClass: DefaultFallbackStrategy,
            deps: [TRANSLOCO_CONFIG],
        },
    ];
    var TranslocoModule = /** @class */ (function () {
        function TranslocoModule() {
        }
        return TranslocoModule;
    }());
    TranslocoModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TranslocoModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoModule, declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent], exports: [TranslocoDirective, TranslocoPipe] });
    TranslocoModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoModule, providers: [defaultProviders] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],
                        providers: [defaultProviders],
                        exports: [TranslocoDirective, TranslocoPipe],
                        entryComponents: [TranslocoLoaderComponent],
                    }]
            }] });

    var TRANSLOCO_TEST_LANGS = new i0.InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');
    var TRANSLOCO_TEST_OPTIONS = new i0.InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');
    var TestingLoader = /** @class */ (function () {
        function TestingLoader(langs) {
            this.langs = langs;
        }
        TestingLoader.prototype.getTranslation = function (lang) {
            return rxjs.of(this.langs[lang]);
        };
        return TestingLoader;
    }());
    TestingLoader.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TestingLoader, deps: [{ token: TRANSLOCO_TEST_LANGS }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TestingLoader.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TestingLoader });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TestingLoader, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [TRANSLOCO_TEST_LANGS]
                        }] }];
        } });
    function initTranslocoService(service, langs, options) {
        if (langs === void 0) { langs = {}; }
        var preloadAllLangs = function () { return options.preloadLangs
            ? Promise.all(Object.keys(langs).map(function (lang) { return service.load(lang).toPromise(); }))
            : Promise.resolve(); };
        return preloadAllLangs;
    }
    var TranslocoTestingModule = /** @class */ (function () {
        function TranslocoTestingModule() {
        }
        TranslocoTestingModule.forRoot = function (options) {
            return {
                ngModule: TranslocoTestingModule,
                providers: [
                    {
                        provide: TRANSLOCO_TEST_LANGS,
                        useValue: options.langs,
                    },
                    {
                        provide: TRANSLOCO_TEST_OPTIONS,
                        useValue: options,
                    },
                    {
                        provide: i0.APP_INITIALIZER,
                        useFactory: initTranslocoService,
                        deps: [
                            TranslocoService,
                            TRANSLOCO_TEST_LANGS,
                            TRANSLOCO_TEST_OPTIONS,
                        ],
                        multi: true,
                    },
                    {
                        provide: TRANSLOCO_LOADER,
                        useClass: TestingLoader,
                    },
                    defaultProviders,
                    {
                        provide: TRANSLOCO_CONFIG,
                        useValue: translocoConfig(Object.assign({ prodMode: true, missingHandler: { logMissingKey: false } }, options.translocoConfig)),
                    },
                ],
            };
        };
        return TranslocoTestingModule;
    }());
    TranslocoTestingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoTestingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TranslocoTestingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoTestingModule, exports: [TranslocoModule] });
    TranslocoTestingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoTestingModule, imports: [TranslocoModule] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TranslocoTestingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        exports: [TranslocoModule],
                    }]
            }] });

    /**
     * Returns the language code name from the browser, e.g. "en"
     */
    function getBrowserLang() {
        var browserLang = getBrowserCultureLang();
        if (!browserLang || !isBrowser()) {
            return undefined;
        }
        if (browserLang.indexOf('-') !== -1) {
            browserLang = browserLang.split('-')[0];
        }
        if (browserLang.indexOf('_') !== -1) {
            browserLang = browserLang.split('_')[0];
        }
        return browserLang;
    }
    /**
     * Returns the culture language code name from the browser, e.g. "en-US"
     */
    function getBrowserCultureLang() {
        if (!isBrowser()) {
            return '';
        }
        var navigator = window.navigator;
        var browserCultureLang = navigator.languages ? navigator.languages[0] : null;
        browserCultureLang =
            browserCultureLang ||
                navigator.language ||
                navigator.browserLanguage ||
                navigator.userLanguage;
        return browserCultureLang;
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DefaultFallbackStrategy = DefaultFallbackStrategy;
    exports.DefaultTranspiler = DefaultTranspiler;
    exports.FunctionalTranspiler = FunctionalTranspiler;
    exports.TRANSLOCO_CONFIG = TRANSLOCO_CONFIG;
    exports.TRANSLOCO_FALLBACK_STRATEGY = TRANSLOCO_FALLBACK_STRATEGY;
    exports.TRANSLOCO_INTERCEPTOR = TRANSLOCO_INTERCEPTOR;
    exports.TRANSLOCO_LANG = TRANSLOCO_LANG;
    exports.TRANSLOCO_LOADER = TRANSLOCO_LOADER;
    exports.TRANSLOCO_LOADING_TEMPLATE = TRANSLOCO_LOADING_TEMPLATE;
    exports.TRANSLOCO_MISSING_HANDLER = TRANSLOCO_MISSING_HANDLER;
    exports.TRANSLOCO_SCOPE = TRANSLOCO_SCOPE;
    exports.TRANSLOCO_TRANSPILER = TRANSLOCO_TRANSPILER;
    exports.TemplateHandler = TemplateHandler;
    exports.TestingLoader = TestingLoader;
    exports.TranslocoDirective = TranslocoDirective;
    exports.TranslocoModule = TranslocoModule;
    exports.TranslocoPipe = TranslocoPipe;
    exports.TranslocoService = TranslocoService;
    exports.TranslocoTestingModule = TranslocoTestingModule;
    exports.coerceArray = coerceArray;
    exports.defaultConfig = defaultConfig;
    exports.defaultProviders = defaultProviders;
    exports.flatten = flatten;
    exports.getBrowserCultureLang = getBrowserCultureLang;
    exports.getBrowserLang = getBrowserLang;
    exports.getFunctionArgs = getFunctionArgs;
    exports.getLangFromScope = getLangFromScope;
    exports.getPipeValue = getPipeValue;
    exports.getScopeFromLang = getScopeFromLang;
    exports.getValue = getValue;
    exports.hasInlineLoader = hasInlineLoader;
    exports.isBrowser = isBrowser;
    exports.isDefined = isDefined;
    exports.isEmpty = isEmpty;
    exports.isFunction = isFunction;
    exports.isNil = isNil;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isScopeObject = isScopeObject;
    exports.isString = isString;
    exports.setValue = setValue;
    exports.size = size;
    exports.toCamelCase = toCamelCase;
    exports.toNumber = toNumber;
    exports.translate = translate;
    exports.translocoConfig = translocoConfig;
    exports.unflatten = unflatten;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngneat-transloco.umd.js.map

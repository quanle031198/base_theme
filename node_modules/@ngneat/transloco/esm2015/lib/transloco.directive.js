import { ChangeDetectorRef, Directive, ElementRef, Inject, Input, Optional, Renderer2, TemplateRef, ViewContainerRef, } from '@angular/core';
import { forkJoin } from 'rxjs';
import { switchMap } from 'rxjs/operators';
import { TemplateHandler } from './template-handler';
import { TRANSLOCO_LANG } from './transloco-lang';
import { TRANSLOCO_LOADING_TEMPLATE } from './transloco-loading-template';
import { TRANSLOCO_SCOPE } from './transloco-scope';
import { TranslocoService } from './transloco.service';
import { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges, } from './shared';
import { LangResolver } from './lang-resolver';
import { ScopeResolver } from './scope-resolver';
import * as i0 from "@angular/core";
import * as i1 from "./transloco.service";
export class TranslocoDirective {
    constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {
        this.translocoService = translocoService;
        this.tpl = tpl;
        this.providerScope = providerScope;
        this.providerLang = providerLang;
        this.providedLoadingTpl = providedLoadingTpl;
        this.vcr = vcr;
        this.cdr = cdr;
        this.host = host;
        this.renderer = renderer;
        this.subscription = null;
        this.translationMemo = {};
        this.params = {};
        // Whether we already rendered the view once
        this.initialized = false;
        this.langResolver = new LangResolver();
        this.scopeResolver = new ScopeResolver(this.translocoService);
        this.strategy = this.tpl === null ? 'attribute' : 'structural';
    }
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    ngOnInit() {
        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);
        this.subscription = this.translocoService.langChanges$
            .pipe(switchMap((activeLang) => {
            const lang = this.langResolver.resolve({
                inline: this.inlineLang,
                provider: this.providerLang,
                active: activeLang,
            });
            return Array.isArray(this.providerScope)
                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))
                : this.resolveScope(lang, this.providerScope);
        }), listenOrNotOperator(listenToLangChange))
            .subscribe(() => {
            this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);
            this.strategy === 'attribute'
                ? this.attributeStrategy()
                : this.structuralStrategy(this.currentLang, this.inlineRead);
            this.cdr.markForCheck();
            this.initialized = true;
        });
        const loadingTpl = this.getLoadingTpl();
        if (!this.initialized && loadingTpl) {
            this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);
            this.loaderTplHandler.attachView();
        }
    }
    ngOnChanges(changes) {
        // We need to support dynamic keys/params, so if this is not the first change CD cycle
        // we need to run the function again in order to update the value
        if (this.strategy === 'attribute') {
            const notInit = Object.keys(changes).some((v) => !changes[v].firstChange);
            notInit && this.attributeStrategy();
        }
    }
    attributeStrategy() {
        this.detachLoader();
        this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));
    }
    structuralStrategy(lang, read) {
        this.translationMemo = {};
        if (this.view) {
            // when the lang changes we need to change the reference so Angular will update the view
            this.view.context['$implicit'] = this.getTranslateFn(lang, read);
            this.view.context['currentLang'] = this.currentLang;
        }
        else {
            this.detachLoader();
            this.view = this.vcr.createEmbeddedView(this.tpl, {
                $implicit: this.getTranslateFn(lang, read),
                currentLang: this.currentLang,
            });
        }
    }
    getTranslateFn(lang, read) {
        return (key, params) => {
            const withRead = read ? `${read}.${key}` : key;
            const withParams = params
                ? `${withRead}${JSON.stringify(params)}`
                : withRead;
            if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {
                return this.translationMemo[withParams].value;
            }
            this.translationMemo[withParams] = {
                params,
                value: this.translocoService.translate(withRead, params, lang),
            };
            return this.translationMemo[withParams].value;
        };
    }
    getLoadingTpl() {
        return this.inlineTpl || this.providedLoadingTpl;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
            // callback within its `destination` property, preventing classes from being GC'd.
            this.subscription = null;
        }
    }
    detachLoader() {
        var _a;
        (_a = this.loaderTplHandler) === null || _a === void 0 ? void 0 : _a.detachView();
    }
    resolveScope(lang, providerScope) {
        const resolvedScope = this.scopeResolver.resolve({
            inline: this.inlineScope,
            provider: providerScope,
        });
        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);
        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);
        return this.translocoService._loadDependencies(this.path, inlineLoader);
    }
}
TranslocoDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: TranslocoDirective, deps: [{ token: i1.TranslocoService }, { token: i0.TemplateRef, optional: true }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: TRANSLOCO_LOADING_TEMPLATE, optional: true }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
TranslocoDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.5", type: TranslocoDirective, selector: "[transloco]", inputs: { key: ["transloco", "key"], params: ["translocoParams", "params"], inlineScope: ["translocoScope", "inlineScope"], inlineRead: ["translocoRead", "inlineRead"], inlineLang: ["translocoLang", "inlineLang"], inlineTpl: ["translocoLoadingTpl", "inlineTpl"] }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: TranslocoDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[transloco]',
                }]
        }], ctorParameters: function () { return [{ type: i1.TranslocoService }, { type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_SCOPE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_LANG]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_LOADING_TEMPLATE]
                }] }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { key: [{
                type: Input,
                args: ['transloco']
            }], params: [{
                type: Input,
                args: ['translocoParams']
            }], inlineScope: [{
                type: Input,
                args: ['translocoScope']
            }], inlineRead: [{
                type: Input,
                args: ['translocoRead']
            }], inlineLang: [{
                type: Input,
                args: ['translocoLang']
            }], inlineTpl: [{
                type: Input,
                args: ['translocoLoadingTpl']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvdHJhbnNsb2NvL3NyYy9saWIvdHJhbnNsb2NvLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBRVYsTUFBTSxFQUNOLEtBQUssRUFJTCxRQUFRLEVBQ1IsU0FBUyxFQUVULFdBQVcsRUFFWCxnQkFBZ0IsR0FDakIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFFBQVEsRUFBNEIsTUFBTSxNQUFNLENBQUM7QUFDMUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxlQUFlLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDMUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXZELE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIsbUJBQW1CLEVBQ25CLHlCQUF5QixHQUMxQixNQUFNLFVBQVUsQ0FBQztBQUNsQixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDOzs7QUFXakQsTUFBTSxPQUFPLGtCQUFrQjtJQThCN0IsWUFDVSxnQkFBa0MsRUFDdEIsR0FBNkIsRUFHekMsYUFBeUMsRUFHekMsWUFBZ0MsRUFHaEMsa0JBQTBDLEVBQzFDLEdBQXFCLEVBQ3JCLEdBQXNCLEVBQ3RCLElBQWdCLEVBQ2hCLFFBQW1CO1FBZG5CLHFCQUFnQixH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QkFDUixNQUFNOzJCQUFDLDBCQUEwQjs0SkFqQ2hCLEdBQUc7c0JBQXRCLEtBQUs7dUJBQUMsV0FBVztnQkFDUSxNQUFNO3NCQUEvQixLQUFLO3VCQUFDLGlCQUFpQjtnQkFDQyxXQUFXO3NCQUFuQyxLQUFLO3VCQUFDLGdCQUFnQjtnQkFDQyxVQUFVO3NCQUFqQyxLQUFLO3VCQUFDLGVBQWU7Z0JBQ0UsVUFBVTtzQkFBakMsS0FBSzt1QkFBQyxlQUFlO2dCQUNRLFNBQVM7c0JBQXRDLEtBQUs7dUJBQUMscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRW1iZWRkZWRWaWV3UmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgUmVuZGVyZXIyLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZixcbiAgVHlwZSxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmb3JrSm9pbiwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUhhbmRsZXIsIFZpZXcgfSBmcm9tICcuL3RlbXBsYXRlLWhhbmRsZXInO1xuaW1wb3J0IHsgVFJBTlNMT0NPX0xBTkcgfSBmcm9tICcuL3RyYW5zbG9jby1sYW5nJztcbmltcG9ydCB7IFRSQU5TTE9DT19MT0FESU5HX1RFTVBMQVRFIH0gZnJvbSAnLi90cmFuc2xvY28tbG9hZGluZy10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBUUkFOU0xPQ09fU0NPUEUgfSBmcm9tICcuL3RyYW5zbG9jby1zY29wZSc7XG5pbXBvcnQgeyBUcmFuc2xvY29TZXJ2aWNlIH0gZnJvbSAnLi90cmFuc2xvY28uc2VydmljZSc7XG5pbXBvcnQgeyBIYXNoTWFwLCBNYXliZUFycmF5LCBUcmFuc2xhdGlvbiwgVHJhbnNsb2NvU2NvcGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIGxpc3Rlbk9yTm90T3BlcmF0b3IsXG4gIHJlc29sdmVJbmxpbmVMb2FkZXIsXG4gIHNob3VsZExpc3RlblRvTGFuZ0NoYW5nZXMsXG59IGZyb20gJy4vc2hhcmVkJztcbmltcG9ydCB7IExhbmdSZXNvbHZlciB9IGZyb20gJy4vbGFuZy1yZXNvbHZlcic7XG5pbXBvcnQgeyBTY29wZVJlc29sdmVyIH0gZnJvbSAnLi9zY29wZS1yZXNvbHZlcic7XG5cbnR5cGUgVHJhbnNsYXRlRm4gPSAoa2V5OiBzdHJpbmcsIHBhcmFtcz86IEhhc2hNYXApID0+IGFueTtcbmludGVyZmFjZSBWaWV3Q29udGV4dCB7XG4gICRpbXBsaWNpdDogVHJhbnNsYXRlRm47XG4gIGN1cnJlbnRMYW5nOiBzdHJpbmc7XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t0cmFuc2xvY29dJyxcbn0pXG5leHBvcnQgY2xhc3MgVHJhbnNsb2NvRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG4gIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHZpZXc6IEVtYmVkZGVkVmlld1JlZjxWaWV3Q29udGV4dD4gfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSB0cmFuc2xhdGlvbk1lbW86IFJlY29yZDxzdHJpbmcsIHsgdmFsdWU6IGFueTsgcGFyYW1zPzogSGFzaE1hcCB9PiA9XG4gICAge307XG5cbiAgQElucHV0KCd0cmFuc2xvY28nKSBrZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgQElucHV0KCd0cmFuc2xvY29QYXJhbXMnKSBwYXJhbXM6IEhhc2hNYXAgPSB7fTtcbiAgQElucHV0KCd0cmFuc2xvY29TY29wZScpIGlubGluZVNjb3BlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIEBJbnB1dCgndHJhbnNsb2NvUmVhZCcpIGlubGluZVJlYWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgQElucHV0KCd0cmFuc2xvY29MYW5nJykgaW5saW5lTGFuZzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBASW5wdXQoJ3RyYW5zbG9jb0xvYWRpbmdUcGwnKSBpbmxpbmVUcGw6IFRlbXBsYXRlUmVmPHVua25vd24+IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgY3VycmVudExhbmc6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBsb2FkZXJUcGxIYW5kbGVyOiBUZW1wbGF0ZUhhbmRsZXIgfCB1bmRlZmluZWQ7XG4gIC8vIFdoZXRoZXIgd2UgYWxyZWFkeSByZW5kZXJlZCB0aGUgdmlldyBvbmNlXG4gIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgbGFuZ1Jlc29sdmVyID0gbmV3IExhbmdSZXNvbHZlcigpO1xuICBwcml2YXRlIHNjb3BlUmVzb2x2ZXIgPSBuZXcgU2NvcGVSZXNvbHZlcih0aGlzLnRyYW5zbG9jb1NlcnZpY2UpO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0cmF0ZWd5OiAnc3RydWN0dXJhbCcgfCAnYXR0cmlidXRlJztcblxuICBzdGF0aWMgbmdUZW1wbGF0ZUNvbnRleHRHdWFyZChcbiAgICBkaXI6IFRyYW5zbG9jb0RpcmVjdGl2ZSxcbiAgICBjdHg6IHVua25vd25cbiAgKTogY3R4IGlzIFZpZXdDb250ZXh0IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdHJhbnNsb2NvU2VydmljZTogVHJhbnNsb2NvU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIHRwbDogVGVtcGxhdGVSZWY8Vmlld0NvbnRleHQ+LFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChUUkFOU0xPQ09fU0NPUEUpXG4gICAgcHJpdmF0ZSBwcm92aWRlclNjb3BlOiBNYXliZUFycmF5PFRyYW5zbG9jb1Njb3BlPixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0xBTkcpXG4gICAgcHJpdmF0ZSBwcm92aWRlckxhbmc6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0xPQURJTkdfVEVNUExBVEUpXG4gICAgcHJpdmF0ZSBwcm92aWRlZExvYWRpbmdUcGw6IFR5cGU8dW5rbm93bj4gfCBzdHJpbmcsXG4gICAgcHJpdmF0ZSB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgaG9zdDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgKSB7XG4gICAgdGhpcy5zdHJhdGVneSA9IHRoaXMudHBsID09PSBudWxsID8gJ2F0dHJpYnV0ZScgOiAnc3RydWN0dXJhbCc7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBjb25zdCBsaXN0ZW5Ub0xhbmdDaGFuZ2UgPSBzaG91bGRMaXN0ZW5Ub0xhbmdDaGFuZ2VzKFxuICAgICAgdGhpcy50cmFuc2xvY29TZXJ2aWNlLFxuICAgICAgdGhpcy5wcm92aWRlckxhbmcgfHwgdGhpcy5pbmxpbmVMYW5nXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy50cmFuc2xvY29TZXJ2aWNlLmxhbmdDaGFuZ2VzJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCgoYWN0aXZlTGFuZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGxhbmcgPSB0aGlzLmxhbmdSZXNvbHZlci5yZXNvbHZlKHtcbiAgICAgICAgICAgIGlubGluZTogdGhpcy5pbmxpbmVMYW5nLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXJMYW5nLFxuICAgICAgICAgICAgYWN0aXZlOiBhY3RpdmVMYW5nLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5wcm92aWRlclNjb3BlKVxuICAgICAgICAgICAgPyBmb3JrSm9pbihcbiAgICAgICAgICAgICAgICAoPFRyYW5zbG9jb1Njb3BlW10+dGhpcy5wcm92aWRlclNjb3BlKS5tYXAoKHByb3ZpZGVyU2NvcGUpID0+XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVTY29wZShsYW5nLCBwcm92aWRlclNjb3BlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiB0aGlzLnJlc29sdmVTY29wZShsYW5nLCB0aGlzLnByb3ZpZGVyU2NvcGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgbGlzdGVuT3JOb3RPcGVyYXRvcihsaXN0ZW5Ub0xhbmdDaGFuZ2UpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGFuZyA9IHRoaXMubGFuZ1Jlc29sdmVyLnJlc29sdmVMYW5nQmFzZWRPblNjb3BlKFxuICAgICAgICAgIHRoaXMucGF0aCFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9PT0gJ2F0dHJpYnV0ZSdcbiAgICAgICAgICA/IHRoaXMuYXR0cmlidXRlU3RyYXRlZ3koKVxuICAgICAgICAgIDogdGhpcy5zdHJ1Y3R1cmFsU3RyYXRlZ3kodGhpcy5jdXJyZW50TGFuZywgdGhpcy5pbmxpbmVSZWFkKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICBjb25zdCBsb2FkaW5nVHBsID0gdGhpcy5nZXRMb2FkaW5nVHBsKCk7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkICYmIGxvYWRpbmdUcGwpIHtcbiAgICAgIHRoaXMubG9hZGVyVHBsSGFuZGxlciA9IG5ldyBUZW1wbGF0ZUhhbmRsZXIobG9hZGluZ1RwbCwgdGhpcy52Y3IpO1xuICAgICAgdGhpcy5sb2FkZXJUcGxIYW5kbGVyLmF0dGFjaFZpZXcoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgLy8gV2UgbmVlZCB0byBzdXBwb3J0IGR5bmFtaWMga2V5cy9wYXJhbXMsIHNvIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCBjaGFuZ2UgQ0QgY3ljbGVcbiAgICAvLyB3ZSBuZWVkIHRvIHJ1biB0aGUgZnVuY3Rpb24gYWdhaW4gaW4gb3JkZXIgdG8gdXBkYXRlIHRoZSB2YWx1ZVxuICAgIGlmICh0aGlzLnN0cmF0ZWd5ID09PSAnYXR0cmlidXRlJykge1xuICAgICAgY29uc3Qgbm90SW5pdCA9IE9iamVjdC5rZXlzKGNoYW5nZXMpLnNvbWUoKHYpID0+ICFjaGFuZ2VzW3ZdLmZpcnN0Q2hhbmdlKTtcbiAgICAgIG5vdEluaXQgJiYgdGhpcy5hdHRyaWJ1dGVTdHJhdGVneSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXR0cmlidXRlU3RyYXRlZ3koKSB7XG4gICAgdGhpcy5kZXRhY2hMb2FkZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KFxuICAgICAgdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQsXG4gICAgICAnaW5uZXJUZXh0JyxcbiAgICAgIHRoaXMudHJhbnNsb2NvU2VydmljZS50cmFuc2xhdGUodGhpcy5rZXkhLCB0aGlzLnBhcmFtcywgdGhpcy5jdXJyZW50TGFuZylcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdHJ1Y3R1cmFsU3RyYXRlZ3kobGFuZzogc3RyaW5nLCByZWFkPzogc3RyaW5nKSB7XG4gICAgdGhpcy50cmFuc2xhdGlvbk1lbW8gPSB7fTtcblxuICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgIC8vIHdoZW4gdGhlIGxhbmcgY2hhbmdlcyB3ZSBuZWVkIHRvIGNoYW5nZSB0aGUgcmVmZXJlbmNlIHNvIEFuZ3VsYXIgd2lsbCB1cGRhdGUgdGhlIHZpZXdcbiAgICAgIHRoaXMudmlldy5jb250ZXh0WyckaW1wbGljaXQnXSA9IHRoaXMuZ2V0VHJhbnNsYXRlRm4obGFuZywgcmVhZCk7XG4gICAgICB0aGlzLnZpZXcuY29udGV4dFsnY3VycmVudExhbmcnXSA9IHRoaXMuY3VycmVudExhbmchO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRldGFjaExvYWRlcigpO1xuICAgICAgdGhpcy52aWV3ID0gdGhpcy52Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudHBsLCB7XG4gICAgICAgICRpbXBsaWNpdDogdGhpcy5nZXRUcmFuc2xhdGVGbihsYW5nLCByZWFkKSxcbiAgICAgICAgY3VycmVudExhbmc6IHRoaXMuY3VycmVudExhbmchLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGdldFRyYW5zbGF0ZUZuKFxuICAgIGxhbmc6IHN0cmluZyxcbiAgICByZWFkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogVHJhbnNsYXRlRm4ge1xuICAgIHJldHVybiAoa2V5OiBzdHJpbmcsIHBhcmFtcz86IEhhc2hNYXApID0+IHtcbiAgICAgIGNvbnN0IHdpdGhSZWFkID0gcmVhZCA/IGAke3JlYWR9LiR7a2V5fWAgOiBrZXk7XG4gICAgICBjb25zdCB3aXRoUGFyYW1zID0gcGFyYW1zXG4gICAgICAgID8gYCR7d2l0aFJlYWR9JHtKU09OLnN0cmluZ2lmeShwYXJhbXMpfWBcbiAgICAgICAgOiB3aXRoUmVhZDtcblxuICAgICAgaWYgKFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy50cmFuc2xhdGlvbk1lbW8sIHdpdGhQYXJhbXMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRpb25NZW1vW3dpdGhQYXJhbXNdLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYW5zbGF0aW9uTWVtb1t3aXRoUGFyYW1zXSA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB2YWx1ZTogdGhpcy50cmFuc2xvY29TZXJ2aWNlLnRyYW5zbGF0ZSh3aXRoUmVhZCwgcGFyYW1zLCBsYW5nKSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9uTWVtb1t3aXRoUGFyYW1zXS52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRMb2FkaW5nVHBsKCk6IFZpZXcge1xuICAgIHJldHVybiB0aGlzLmlubGluZVRwbCB8fCB0aGlzLnByb3ZpZGVkTG9hZGluZ1RwbDtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIC8vIENhcmV0YWtlciBub3RlOiBpdCdzIGltcG9ydGFudCB0byBjbGVhbiB1cCByZWZlcmVuY2VzIHRvIHN1YnNjcmlwdGlvbnMgc2luY2UgdGhleSBzYXZlIHRoZSBgbmV4dGBcbiAgICAgIC8vIGNhbGxiYWNrIHdpdGhpbiBpdHMgYGRlc3RpbmF0aW9uYCBwcm9wZXJ0eSwgcHJldmVudGluZyBjbGFzc2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRldGFjaExvYWRlcigpIHtcbiAgICB0aGlzLmxvYWRlclRwbEhhbmRsZXI/LmRldGFjaFZpZXcoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZVNjb3BlKFxuICAgIGxhbmc6IHN0cmluZyxcbiAgICBwcm92aWRlclNjb3BlOiBUcmFuc2xvY29TY29wZVxuICApOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uIHwgVHJhbnNsYXRpb25bXT4ge1xuICAgIGNvbnN0IHJlc29sdmVkU2NvcGUgPSB0aGlzLnNjb3BlUmVzb2x2ZXIucmVzb2x2ZSh7XG4gICAgICBpbmxpbmU6IHRoaXMuaW5saW5lU2NvcGUsXG4gICAgICBwcm92aWRlcjogcHJvdmlkZXJTY29wZSxcbiAgICB9KTtcbiAgICB0aGlzLnBhdGggPSB0aGlzLmxhbmdSZXNvbHZlci5yZXNvbHZlTGFuZ1BhdGgobGFuZywgcmVzb2x2ZWRTY29wZSk7XG4gICAgY29uc3QgaW5saW5lTG9hZGVyID0gcmVzb2x2ZUlubGluZUxvYWRlcihwcm92aWRlclNjb3BlLCByZXNvbHZlZFNjb3BlKTtcblxuICAgIHJldHVybiB0aGlzLnRyYW5zbG9jb1NlcnZpY2UuX2xvYWREZXBlbmRlbmNpZXModGhpcy5wYXRoLCBpbmxpbmVMb2FkZXIpO1xuICB9XG59XG4iXX0=
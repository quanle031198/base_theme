import { ChangeDetectorRef, Inject, Optional, Pipe, } from '@angular/core';
import { TranslocoService } from './transloco.service';
import { switchMap } from 'rxjs/operators';
import { forkJoin } from 'rxjs';
import { TRANSLOCO_SCOPE } from './transloco-scope';
import { TRANSLOCO_LANG } from './transloco-lang';
import { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges, } from './shared';
import { LangResolver } from './lang-resolver';
import { ScopeResolver } from './scope-resolver';
import * as i0 from "@angular/core";
import * as i1 from "./transloco.service";
export class TranslocoPipe {
    constructor(translocoService, providerScope, providerLang, cdr) {
        this.translocoService = translocoService;
        this.providerScope = providerScope;
        this.providerLang = providerLang;
        this.cdr = cdr;
        this.subscription = null;
        this.lastValue = '';
        this.langResolver = new LangResolver();
        this.scopeResolver = new ScopeResolver(this.translocoService);
    }
    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311
    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488
    transform(key, params, inlineLang) {
        var _a;
        if (!key) {
            return key;
        }
        const keyName = params ? `${key}${JSON.stringify(params)}` : key;
        if (keyName === this.lastKey) {
            return this.lastValue;
        }
        this.lastKey = keyName;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);
        this.subscription = this.translocoService.langChanges$
            .pipe(switchMap((activeLang) => {
            const lang = this.langResolver.resolve({
                inline: inlineLang,
                provider: this.providerLang,
                active: activeLang,
            });
            return Array.isArray(this.providerScope)
                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))
                : this.resolveScope(lang, this.providerScope);
        }), listenOrNotOperator(listenToLangChange))
            .subscribe(() => this.updateValue(key, params));
        return this.lastValue;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
            // callback within its `destination` property, preventing classes from being GC'd.
            this.subscription = null;
        }
    }
    updateValue(key, params) {
        const lang = this.langResolver.resolveLangBasedOnScope(this.path);
        this.lastValue = this.translocoService.translate(key, params, lang);
        this.cdr.markForCheck();
    }
    resolveScope(lang, providerScope) {
        const resolvedScope = this.scopeResolver.resolve({
            inline: undefined,
            provider: providerScope,
        });
        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);
        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);
        return this.translocoService._loadDependencies(this.path, inlineLoader);
    }
}
TranslocoPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: TranslocoPipe, deps: [{ token: i1.TranslocoService }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Pipe });
TranslocoPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: TranslocoPipe, name: "transloco", pure: false });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: TranslocoPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'transloco',
                    pure: false,
                }]
        }], ctorParameters: function () { return [{ type: i1.TranslocoService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_SCOPE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_LANG]
                }] }, { type: i0.ChangeDetectorRef }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnBpcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL3RyYW5zbG9jby9zcmMvbGliL3RyYW5zbG9jby5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsTUFBTSxFQUVOLFFBQVEsRUFDUixJQUFJLEdBRUwsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFdkQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxRQUFRLEVBQTRCLE1BQU0sTUFBTSxDQUFDO0FBQzFELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUNMLG1CQUFtQixFQUNuQixtQkFBbUIsRUFDbkIseUJBQXlCLEdBQzFCLE1BQU0sVUFBVSxDQUFDO0FBQ2xCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7OztBQU1qRCxNQUFNLE9BQU8sYUFBYTtJQVF4QixZQUNVLGdCQUFrQyxFQUdsQyxhQUFxRCxFQUdyRCxZQUFnQyxFQUNoQyxHQUFzQjtRQVB0QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBR2xDLGtCQUFhLEdBQWIsYUFBYSxDQUF3QztRQUdyRCxpQkFBWSxHQUFaLFlBQVksQ0FBb0I7UUFDaEMsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFmeEIsaUJBQVksR0FBd0IsSUFBSSxDQUFDO1FBQ3pDLGNBQVMsR0FBRyxFQUFFLENBQUM7UUFHZixpQkFBWSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDbEMsa0JBQWEsR0FBRyxJQUFJLGFB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QVksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ25FLE1BQU0sWUFBWSxHQUFHLG1CQUFtQixDQUFDLGFBQWEsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUN2RSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQzFFLENBQUM7OzBHQTlGVSxhQUFhLGtEQVdkLGVBQWUsNkJBR2YsY0FBYzt3R0FkYixhQUFhOzJGQUFiLGFBQWE7a0JBSnpCLElBQUk7bUJBQUM7b0JBQ0osSUFBSSxFQUFFLFdBQVc7b0JBQ2pCLElBQUksRUFBRSxLQUFLO2lCQUNaOzswQkFXSSxRQUFROzswQkFDUixNQUFNOzJCQUFDLGVBQWU7OzBCQUV0QixRQUFROzswQkFDUixNQUFNOzJCQUFDLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgSW5qZWN0LFxuICBPbkRlc3Ryb3ksXG4gIE9wdGlvbmFsLFxuICBQaXBlLFxuICBQaXBlVHJhbnNmb3JtLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyYW5zbG9jb1NlcnZpY2UgfSBmcm9tICcuL3RyYW5zbG9jby5zZXJ2aWNlJztcbmltcG9ydCB7IEhhc2hNYXAsIE1heWJlQXJyYXksIFRyYW5zbGF0aW9uLCBUcmFuc2xvY29TY29wZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZm9ya0pvaW4sIE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgVFJBTlNMT0NPX1NDT1BFIH0gZnJvbSAnLi90cmFuc2xvY28tc2NvcGUnO1xuaW1wb3J0IHsgVFJBTlNMT0NPX0xBTkcgfSBmcm9tICcuL3RyYW5zbG9jby1sYW5nJztcbmltcG9ydCB7XG4gIGxpc3Rlbk9yTm90T3BlcmF0b3IsXG4gIHJlc29sdmVJbmxpbmVMb2FkZXIsXG4gIHNob3VsZExpc3RlblRvTGFuZ0NoYW5nZXMsXG59IGZyb20gJy4vc2hhcmVkJztcbmltcG9ydCB7IExhbmdSZXNvbHZlciB9IGZyb20gJy4vbGFuZy1yZXNvbHZlcic7XG5pbXBvcnQgeyBTY29wZVJlc29sdmVyIH0gZnJvbSAnLi9zY29wZS1yZXNvbHZlcic7XG5cbkBQaXBlKHtcbiAgbmFtZTogJ3RyYW5zbG9jbycsXG4gIHB1cmU6IGZhbHNlLFxufSlcbmV4cG9ydCBjbGFzcyBUcmFuc2xvY29QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGxhc3RWYWx1ZSA9ICcnO1xuICBwcml2YXRlIGxhc3RLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgbGFuZ1Jlc29sdmVyID0gbmV3IExhbmdSZXNvbHZlcigpO1xuICBwcml2YXRlIHNjb3BlUmVzb2x2ZXIgPSBuZXcgU2NvcGVSZXNvbHZlcih0aGlzLnRyYW5zbG9jb1NlcnZpY2UpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdHJhbnNsb2NvU2VydmljZTogVHJhbnNsb2NvU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoVFJBTlNMT0NPX1NDT1BFKVxuICAgIHByaXZhdGUgcHJvdmlkZXJTY29wZTogTWF5YmVBcnJheTxUcmFuc2xvY29TY29wZT4gfCB1bmRlZmluZWQsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KFRSQU5TTE9DT19MQU5HKVxuICAgIHByaXZhdGUgcHJvdmlkZXJMYW5nOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmXG4gICkge31cblxuICAvLyBudWxsIGlzIGZvciBoYW5kbGluZyBzdHJpY3QgbW9kZSArIGFzeW5jIHBpcGUgdHlwZXMgaHR0cHM6Ly9naXRodWIuY29tL25nbmVhdC90cmFuc2xvY28vaXNzdWVzLzMxMVxuICAvLyBudWxsIGlzIGZvciBoYW5kbGluZyBzdHJpY3QgbW9kZSArIG9wdGlvbmFsIGNoYWluaW5nIHR5cGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ25lYXQvdHJhbnNsb2NvL2lzc3Vlcy80ODhcbiAgdHJhbnNmb3JtKFxuICAgIGtleT86IHN0cmluZyB8IG51bGwsXG4gICAgcGFyYW1zPzogSGFzaE1hcCxcbiAgICBpbmxpbmVMYW5nPzogc3RyaW5nXG4gICk6IHN0cmluZyB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgYXMgYW55O1xuICAgIH1cblxuICAgIGNvbnN0IGtleU5hbWUgPSBwYXJhbXMgPyBgJHtrZXl9JHtKU09OLnN0cmluZ2lmeShwYXJhbXMpfWAgOiBrZXk7XG5cbiAgICBpZiAoa2V5TmFtZSA9PT0gdGhpcy5sYXN0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0VmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0S2V5ID0ga2V5TmFtZTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcblxuICAgIGNvbnN0IGxpc3RlblRvTGFuZ0NoYW5nZSA9IHNob3VsZExpc3RlblRvTGFuZ0NoYW5nZXMoXG4gICAgICB0aGlzLnRyYW5zbG9jb1NlcnZpY2UsXG4gICAgICB0aGlzLnByb3ZpZGVyTGFuZyB8fCBpbmxpbmVMYW5nXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy50cmFuc2xvY29TZXJ2aWNlLmxhbmdDaGFuZ2VzJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCgoYWN0aXZlTGFuZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGxhbmcgPSB0aGlzLmxhbmdSZXNvbHZlci5yZXNvbHZlKHtcbiAgICAgICAgICAgIGlubGluZTogaW5saW5lTGFuZyxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyTGFuZyxcbiAgICAgICAgICAgIGFjdGl2ZTogYWN0aXZlTGFuZyxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMucHJvdmlkZXJTY29wZSlcbiAgICAgICAgICAgID8gZm9ya0pvaW4oXG4gICAgICAgICAgICAgICAgKDxUcmFuc2xvY29TY29wZVtdPnRoaXMucHJvdmlkZXJTY29wZSkubWFwKChwcm92aWRlclNjb3BlKSA9PlxuICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlU2NvcGUobGFuZywgcHJvdmlkZXJTY29wZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogdGhpcy5yZXNvbHZlU2NvcGUobGFuZywgdGhpcy5wcm92aWRlclNjb3BlKTtcbiAgICAgICAgfSksXG4gICAgICAgIGxpc3Rlbk9yTm90T3BlcmF0b3IobGlzdGVuVG9MYW5nQ2hhbmdlKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZVZhbHVlKGtleSwgcGFyYW1zKSk7XG5cbiAgICByZXR1cm4gdGhpcy5sYXN0VmFsdWU7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAvLyBDYXJldGFrZXIgbm90ZTogaXQncyBpbXBvcnRhbnQgdG8gY2xlYW4gdXAgcmVmZXJlbmNlcyB0byBzdWJzY3JpcHRpb25zIHNpbmNlIHRoZXkgc2F2ZSB0aGUgYG5leHRgXG4gICAgICAvLyBjYWxsYmFjayB3aXRoaW4gaXRzIGBkZXN0aW5hdGlvbmAgcHJvcGVydHksIHByZXZlbnRpbmcgY2xhc3NlcyBmcm9tIGJlaW5nIEdDJ2QuXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVWYWx1ZShrZXk6IHN0cmluZywgcGFyYW1zPzogSGFzaE1hcCB8IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGxhbmcgPSB0aGlzLmxhbmdSZXNvbHZlci5yZXNvbHZlTGFuZ0Jhc2VkT25TY29wZSh0aGlzLnBhdGghKTtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IHRoaXMudHJhbnNsb2NvU2VydmljZS50cmFuc2xhdGUoa2V5LCBwYXJhbXMsIGxhbmcpO1xuICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlU2NvcGUoXG4gICAgbGFuZzogc3RyaW5nLFxuICAgIHByb3ZpZGVyU2NvcGU6IFRyYW5zbG9jb1Njb3BlXG4gICk6IE9ic2VydmFibGU8VHJhbnNsYXRpb24gfCBUcmFuc2xhdGlvbltdPiB7XG4gICAgY29uc3QgcmVzb2x2ZWRTY29wZSA9IHRoaXMuc2NvcGVSZXNvbHZlci5yZXNvbHZlKHtcbiAgICAgIGlubGluZTogdW5kZWZpbmVkLFxuICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyU2NvcGUsXG4gICAgfSk7XG4gICAgdGhpcy5wYXRoID0gdGhpcy5sYW5nUmVzb2x2ZXIucmVzb2x2ZUxhbmdQYXRoKGxhbmcsIHJlc29sdmVkU2NvcGUpO1xuICAgIGNvbnN0IGlubGluZUxvYWRlciA9IHJlc29sdmVJbmxpbmVMb2FkZXIocHJvdmlkZXJTY29wZSwgcmVzb2x2ZWRTY29wZSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsb2NvU2VydmljZS5fbG9hZERlcGVuZGVuY2llcyh0aGlzLnBhdGgsIGlubGluZUxvYWRlcik7XG4gIH1cbn1cbiJdfQ==